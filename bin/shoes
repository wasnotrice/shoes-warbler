#!/usr/bin/env ruby
$LOAD_PATH.unshift File.expand_path('../../lib', __FILE__)

require 'optparse'
require 'shoes'
require 'shoes/package'
require 'shoes/package/configuration'
require 'shoes/swt/package/app'

class Package
  def initialize(arg)
    @backend, @wrapper = arg.split(':')
  end

  attr_reader :backend, :wrapper
end

class ShoesCLI
  def parse(args)
    options = Struct.new(:packages).new
    options.packages = []

    opts = OptionParser.new do |opts|
      opts.program_name = 'shoes'
      opts.banner = <<-EOS
usage: #{opts.program_name} file
   or: #{opts.program_name} [-p package] file
      EOS
      opts.separator ''
      opts.separator 'Options:'

      opts.on('-p', '--package PACKAGE_TYPE', 'Package as BACKEND:PACKAGE') do |package|
        unless package =~ /^\w+:\w+$/
          abort("#{opts.program_name}: '#{package}' isn't specific enough. See '#{opts.program_name} --help'")
        end
        options.packages << Package.new(package)
      end

      opts.separator ''
      opts.separator 'Examples:'
      opts.separator ''
      opts.separator 'To run a Shoes app:'
      opts.separator ''
      opts.separator '    shoes path/to/shoes/app'
      opts.separator ''
      opts.separator 'To package a Shoes app as an APP and a JAR, using the Swt backend:'
      opts.separator ''
      opts.separator '    shoes -p swt:app -p swt:jar path/to/directory/containing/app'
    end

    opts.parse!(args)
    options
  end

  def package(path, packages = [])
    packages.each do |p|
      config = Shoes::Package::Config.load(path)
      packager = Shoes::Package.new(p.backend, p.wrapper)
      packager.package
    end
  end

  def run(args)
    options = parse args
    package(args.first, options.packages)
  end
end

cli = ShoesCLI.new
cli.run ARGV
